# 第三方库

## 目前 C/C++ 第三方库的分发方式

库的作用就是复用写好的代码。
分发方式有两种，二进制分发和源码分发。

### 二进制分发

二进制分发基本都只提供二进制的库文件、头文件和使用文档。

二进制分发的优点有：（一）隐藏功能实现细节，用户看不到源码。（二）节省编译时间，用户使用时不需要再次编译，直接链接就可以了。

缺点是二进制的库无法跨平台复用，不同的处理器架构和操作系统，使用的二进制格式都会不一样，例如在 x86-linux 上编译的库，拿到 x86-windows 上是用不了的。

选择这种分发方式的一般是**系统自带的包管理工具**和**闭源库**。
系统的包管理工具例如 ubuntu 的 apt-get 和 macos 的 brew。
系统在安装时处理器架构是完全确定的，直接使用二进制分发完全没有问题。

### 源码分发

源码分发的库目前有两种风格，第一种是提供常规的 .h .c/cpp 源码，第二种是提供只有头文件的源码。

常规方式需要用户自己先把源码编译成二进制的静态库或者是动态库，使用时再链接到可执行程序上。

纯头文件方式则不需要提前编译，直接把全部头文件放到自己的项目目录下，include 用到的头文件就行了。
我们用到的 spdlog、eigen 和 boost 的部分模块都是纯头文件库。

常规方式的好处和二进制分发相同，只要编译一次就能重复链接使用。

> 二进制库屏蔽实现细节这个好处还能更进一步——降低库的使用门槛，这是纯头文件库完全不具备的。
> 库的实现可以用任意版本的 c++ 编写，直接用最新的 c++20/23 的新机制去实现需要的功能，最后只需要用 c 语言或用 c++98 这些低版本的语法标准对高版本 c++ 代码再进行一次封装，编译成二进制库给别人用。
> 经过这样的封装的库，只要提供了纯 c 语言编写的头文件，就能让 c 语言的项目用上 c++ 编写的库。
> 提供了符合低版本 c++ 标准语法的头文件，道理也一样。
> 我们用的 zmq 就是这样做的，zmq 用 c++11 实现具体功能，再用 c 语言封装一次。这样既能享受 c++ 的开发效率和运行性能，又能保证最大的兼容性，即便使用 java python 等语言也能够轻易调用提供了 c 语言接口的 zmq。

> TIPS: 在 c++17 之后，c++ 提供了内联变量 (inline variable) 功能，这个功能允许我们在头文件中定义全局变量，并且保证这个头文件被多个 .cpp 文件 include 后不会出现重复定义的问题。
> 在 c++17 以前，全局变量重复定义是阻碍 c++ 库代码 100% 完全头文件化的唯一绊脚石，boost 部分模块需要编译使用也是这个原因。

## 静态库动态库的区别和选择

c/c++ 的库源码经过编译和链接，可以输出为三种类型的目标文件，分别是可执行文件，静态库文件和动态库文件。
在 linux 系统里，静态库文件的后缀是 `.a`，动态库文件的后缀是 `.so`，可执行文件没有后缀。

可执行文件就是我们的程序，可以直接运行。

静态库和动态库内包含了一堆的符号和这些符号实际代表的二进制代码和数据，符号就是源代码中的变量名和函数名。
这些符号在 linux 系统下可以用命令 `nm` 查看。下面是使用 nm 命令查看 libpng.a 时输出的部分内容：

```
0000000000000bf0 T png_get_IHDR
0000000000000fa0 T png_get_PLTE
0000000000001290 T png_get_acTL
00000000000005e0 T png_get_channels
00000000000000f0 T png_get_image_height
00000000000000d0 T png_get_image_width
```

### 两者的区别

静态库和动态库的主要区别体现在**链接阶段**。
链接静态库时，链接器会收集可执行文件用到的全部符号，到静态库中找出全部符号对应的二进制代码或数据复制缝合到可执行文件里。如果链接阶段出现了找不到实际内容的符号，就会出现链接错误 `ld: ... undefined reference ...`。
链接动态库时，链接器同样会收集可执行文件用到的所有符号，也会去动态库中检查用到的符号是否有实际内容，但不会把实际内容复制到可执行文件里。获取符号的实际内容的操作会被延迟到程序启动时进行。

### 两者的优劣

使用静态库的优点有：（一）程序分发方便，复制可执行文件到兼容平台的任意机器上都能直接运行。 （二）程序运行性能略高于使用动态库的程序。

静态库的缺点是可执行文件体积在某些情况下会比使用动态库的更大。

动态库和静态库的优缺点是完全对立的。除了与静态库相反的，还有一个就是动态库能够在不需要重新编译可执行文件的情况下替换不同的动态库实现功能的更新或替换，前提是接口没有改变，即 .h 文件。

### 动态库使用案例

（一）局部更新功能模块。例如把 fullclean 中行为树的代码封装成动态库，这样在不需要更新扫地机里的 fullclean 程序的情况下，更换不同的行为树代码编译的动态库做到更换不同的运行逻辑。
（二）不停机热更新功能模块。linux 在头文件 "dlfcn.h" 里提供了一套函数专门用来干这些事情，例如 dlopen() 函数用来在运行时加载任意一个动态库，dlsym() 函数可以在加载的动态库的文件描述符里通过函数名称获取函数指针。
在 c++ 里有一个叫做**插件化开发**的技术，就是用 "dlfcn.h" 提供的系列函数实现的，能够做到在程序运行的过程中动态增减程序的功能。ROS 里提供的 class loader 机制就是对插件化开发的应用。
（三）系统函数Hook。同样是用 "dlfcn.h" 内的函数实现，目的是在**无法修改源码的情况下**，劫持代理程序内全部的系统函数调用，做到增强系统函数的功能，或者是统计调用信息。

## 包管理工具

目前主流的语言基本都有中心化的项目级别的包管理工具，通过一个配置文件列出需要那些第三方库和库的版本，使用对应的包管理工具敲一下初始化命令就能把需要的库文件或源码下载到项目目录下。

其他语言的包管理工具

* java maven
* python pip
* rust cargo
* nodejs npm
* ...

因为 c/c++ 生态的风气讲究自由，c/c++ 语言也不归属于任何一个组织，大家都想要定义自己的标准，导致生态圈里不管是项目的构建方法还是依赖包的管理方法全都百花齐放，什么风格的都有。
目前 c++ 主流包管理工具中，比较好用的有两个：

* xmake
* vcpkg

vcpkg 是一个非常契合 c++ 生态的包管理工具，不仅能够自动下载编译好的库文件，对于那些编译时通过指定编译选项开启特定功能的库也能够支持（这一点比系统自带的包管理工具做得更好）。
xmake 实际上是对标 cmake 的产品，不是一个单独的包管理工具，xmake 用 lua 脚本来编写项目构建流程，自带的 find package 实现了远程服务器查找包的功能，如果本地没有找到需要的依赖，就会到指定的服务器上下来回来编译。

