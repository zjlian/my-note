## 目前 C/C++ 第三方库的分发方式
库的作用就是复用写好的代码。   
分发方式有两种，二进制分发和源码分发。   

### 二进制分发
二进制分发基本都只提供二进制的库文件、头文件和使用文档。   

二进制分发的优点有：（一）隐藏功能实现细节，用户看不到源码。（二）节省编译时间，用户使用时不需要再次编译，直接链接就可以了。    

缺点是二进制的库无法跨平台复用，不同的处理器架构和操作系统，使用的二进制格式都会不一样，例如在 x86-linux 上编译的库，拿到 x86-windows 上是用不了的。

选择这种分发方式的一般是**系统自带的包管理工具**和**闭源库**。   
系统的包管理工具例如 ubuntu 的 apt-get 和 macos 的 brew。  
系统在安装时处理器架构是完全确定的，直接使用二进制分发完全没有问题。  

### 源码分发
源码分发的库目前有两种风格，第一种是提供常规的 .h .c/cpp 源码，第二种是提供只有头文件的源码。   

常规方式需要用户自己先把源码编译成静态库或者是动态库，使用时再链接到自己的可执行程序上。

纯头文件方式则不需要提前编译，直接把全部头文件放到自己的项目目录下，include 用到的头文件就行了。   
我们用到的 spdlog、eigen 和 boost 的部分模块都是纯头文件库。

常规方式的好处和二进制分发相同，只要编译一次就能重复链接使用。   

屏蔽实现细节这个好处还能更进一步，降级库的使用门槛，这是纯头文件库完全不具备的。  
库的实现可以用任意版本的 c++ 编写，直接用最新的 c++20/23 的新机制去实现需要的功能，最后只需要用 c 语言或用 c++98 这些低版本的语法标准对高版本 c++ 代码再进行一次封装，编译成二进制库给别人用。   
经过这样的封装的库，只要提供了纯 c 语言编写的头文件，就能让 c 语言的项目用上 c++ 编写的库。   
提供了符合低版本 c++ 标准语法的头文件，道理也一样。   

我们用的 zmq 就是这样做的，zmq 用 c++11 实现具体功，再用 c 语言封装一次。这样既能享受 c++ 的开发效率和运行性能，又能保证最大的兼容性，即便使用 java python 等语言也能够轻易调用提供了 c 语言接口的 zmq。  

> 在 c++17 之后，c++ 提供了内联变量 (inline variable) 功能，这个功能允许我们在头文件中定义全局变量，并且保证这个头文件被多个 .cpp 文件 include 后不会出现重复定义的问题。   
> 在 c++17 以前，全局变量重复定义是阻碍 c++ 库代码 100% 完全头文件化的唯一绊脚石，boost 部分模块需要编译使用也是这个原因。   

## 静态库动态库的区别和选择
c/c++ 的库源码经过编译，可以生成**静态库**和**动态库**。

静态库和动态库内都包含了一堆符号和对应的实际内容，符号都是静态/全局变量名称和函数名称。符号对应的内容就是变量的初始值和函数的

动态库使用案例
> ...
根据需求判断如何选择


## 编译流程和 CMake 使用方法
CMake的编译方法
> 绝大部分库的构建方法
Makefile的编译方法
> 上古项目的构建方法
自建构建工具的编译方法
> boost使用自建的构建工具
CMake查找依赖的方法
> ...

## 包管理工具
作用
主流语言例子
c++的包管理工具

