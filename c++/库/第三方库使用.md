## 目前 C/C++ 第三方库的分发方式
库的作用就是复用写好的代码。   
分发方式有两种，二进制分发和源码分发。   

### 二进制分发
二进制分发基本都只提供二进制的库文件、头文件和使用文档。   

二进制分发的优点有：（一）隐藏功能实现细节，用户看不到源码。（二）节省编译时间，用户使用时不需要再次编译，直接链接就可以了。   

缺点是二进制的库无法跨平台复用，不同的处理器架构和操作系统，使用的二进制格式都会不一样，例如在 x86-linux 上编译的库，拿到 x86-windows 上是用不了的。

选择这种分发方式的一般是**系统自带的包管理工具**和**闭源库**。   
系统的包管理工具例如 ubuntu 的 apt-get 和 macos 的 brew。   
系统在安装时处理器架构是完全确定的，直接使用二进制分发完全没有问题。   

### 源码分发
源码分发的库目前有两种风格，第一种是提供常规的 .h .c/cpp 源码，第二种是提供只有头文件的源码。   

常规方式需要用户自己先把源码编译成静态库或者是动态库，使用时再链接到自己的可执行程序上。

纯头文件方式则不需要提前编译，直接把全部头文件放到自己的项目目录下，include 用到的头文件就行了。   
我们用到的 spdlog、eigen 和 boost 的部分模块都是纯头文件库。

常规方式的好处和二进制分发相同，只要编译一次就能重复链接使用。

屏蔽实现细节这个好处还能更进一步，降级库的使用门槛，这是纯头文件库完全不具备的。   
库的实现可以用任意版本的 c++ 编写，直接用最新的 c++20/23 的新机制去实现需要的功能，最后只需要用 c 语言或用 c++98 这些低版本的语法标准对高版本 c++ 代码再进行一次封装，编译成二进制库给别人用。   
经过这样的封装的库，只要提供了纯 c 语言编写的头文件，就能让 c 语言的项目用上 c++ 编写的库。   
提供了符合低版本 c++ 标准语法的头文件，道理也一样。

我们用的 zmq 就是这样做的，zmq 用 c++11 实现具体功，再用 c 语言封装一次。这样既能享受 c++ 的开发效率和运行性能，又能保证最大的兼容性，即便使用 java python 等语言也能够轻易调用提供了 c 语言接口的 zmq。

> 在 c++17 之后，c++ 提供了内联变量 (inline variable) 功能，这个功能允许我们在头文件中定义全局变量，并且保证这个头文件被多个 .cpp 文件 include 后不会出现重复定义的问题。   
> 在 c++17 以前，全局变量重复定义是阻碍 c++ 库代码 100% 完全头文件化的唯一绊脚石，boost 部分模块需要编译使用也是这个原因。

## 静态库动态库的区别和选择
c/c++ 的库源码经过编译和链接，可以输出为三种类型的目标文件，分别是可执行文件，静态库文件和动态库文件。   
在 linux 系统里，静态库文件的后缀是 `.a`，动态库文件的后缀是 `.so`，可执行文件没有后缀。

可执行文件就是我们的程序，可以直接运行。

静态库和动态库内包含了一堆的符号和这些符号实际代表的二进制代码和数据，符号就是源代码中的变量名和函数名。
这些符号在 linux 系统下可以用命令 `nm` 查看。下面是使用 nm 命令查看 libpng.a 时输出的部分内容：
```
0000000000000bf0 T png_get_IHDR
0000000000000fa0 T png_get_PLTE
0000000000001290 T png_get_acTL
00000000000005e0 T png_get_channels
00000000000000f0 T png_get_image_height
00000000000000d0 T png_get_image_width
```

### 两者的区别
静态库和动态库的主要区别体现在**链接阶段**。   
链接静态库时，链接器会收集可执行文件用到的全部符号，到静态库中找出全部符号对应的二进制代码或数据复制缝合到可执行文件里。如果链接阶段出现了找不到实际内容的符号，就会出现链接错误 `ld: ... undefined reference ...`。   
链接动态库时，链接器同样会收集可执行文件用到的所有符号，也会去动态库中检查用到的符号是否有实际内容，但不会把实际内容复制到可执行文件里。获取符号的实际内容的操作会被延迟到程序启动时进行。

### 两者的优劣
使用静态库的优点：
* 程序分发方便，复制可执行文件到兼容平台的任意机器上都能直接运行；
* 程序运行性能略高于使用动态库的程序；

静态库的缺点：
* 可执行文件体积会比使用动态库的更大；

动态库和静态库的优缺点是完全对立的。除了与静态库相反的，还有一个就是动态库能够在不需要重新编译可执行文件的情况下替换不同的动态库实现功能的更新或替换，前提是接口没有改变，即 .h 文件。

### 动态库使用案例
（一）局部更新功能模块，例如把 fullclean 中行为树的代码封装成动态库，这样在不需要更新扫地机里的 fullclean 程序的情况下，更换不同的行为树代码编译的动态库做到更换不同的运行逻辑。   
（二）不停机热更新功能模块，   
（三）系统函数Hook，   

根据需求判断如何选择


## 编译流程和 CMake 使用方法
CMake的编译方法
> 绝大部分库的构建方法
Makefile的编译方法
> 上古项目的构建方法
自建构建工具的编译方法
> boost使用自建的构建工具
CMake查找依赖的方法
> ...

## 包管理工具
作用
主流语言例子
c++的包管理工具

