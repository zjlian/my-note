# 调度算法

调度算法处理的问题是：从就绪队列中选择一个进程分配 CPU。

## 1. 先到先服务调度（First-Come First-Served, FCFS）
这是实现起来最简单的调度算法，当进程进入就绪队列时，将进程 PCB 加入到队尾即可。     
FCFS策略的缺点是平均等待时间会很长。   
FCFS调度算法是非抢占的，当一个进程被分配 CPU，后必须等待他执行完成，才能分配给下一个进程。  


## 2. 最短作业优先调度（Shortest-Job-First, SJF）
这个算法会选择**最短下次 CPU 执行**的进程进行调度，如果是两个同样执行时间的进程，则使用 FCFS 算法进行调度。     
SJF 算法已被证明是最优的调度算法，但现实情况是，我们很难知道进程下次 CPU 执行的长度，所以无法在短期调度上加以实现。     
SJF 算法经常用于长期调度。有一种近似 SJF 的算法，通过上一次 CPU 执行长度预测下一次的长度，计算以前 CPU 执行的长度的**平均指数**作为预测的下一次长度。       

设 $t_n$ 为第 n 个 CPU 执行长度，设 $τ_(n+1)$  为预测的下一次 CPU 执行时间，设 $0≤a≤1$      
定义 $τ_(n+1)=at_n+(1−a) τ_n$     

SJF 算法可以是抢占的或非抢占的，抢占的 SJF 算法在一个新进程到达就绪队列后，就会与正在执行的进程进行对比，如果就绪进程的 CPU 执行的长度比正在执行的进程的小，抢占 SJF 算法就会抢占正在运行的进程。       
抢占 SJF 调度有时称为 **最短剩余时间优先 (shortest-remaining-time-first)** 调度。       

## 3. 优先级调度（priority-scheduling）
SJF 算法可以说是优先级调度算法的一个特例。每一个进程都有一个优先级与其关联，具有高优先级的进程会优先分配cpu。若两个进程优先级相同，则使用 FCFS 算法。       
SJF 算法就是将预测到的进程下次 CPU 执行的长度作为优先级，越短的优先级越高，越长优先级越短。     
优先调度算法也可以是抢占的，当到达就绪队列的新进程的优先级高于正在运行的进程，那么就会进行抢占。        
优先级调度算法中有一个主要的问题是**无穷阻塞**或着叫**饥饿**。就绪运行但是等待 CPU 的进程可以看作是阻塞的。当计算机系统会稳定产生更高优先级的进程流时，低优先级的进程永远都拿不到 CPU。     
解决低优先级进程无穷阻塞的方法之一是**老化**。逐渐增加在系统中长时间等待的进程的优先级。        

## 4. 转轮调度（Round-Robin, RR）
转轮调度算法是专门为分时操作系统设计的。        
他与 FCFS 类似，但加增加了抢占切换进程。将一个较小的时间单元定义为**时间量**或**时间片**。时间片大小通常为10~100ms。就绪队列作为循环队列，CPU 调度程序循环整个队列，为每个进程分配不超过一个时间片的 CPU。      
当被分配 CPU 的的进程执行小于时间片时，进程执行完成后会自动释放 CPU，调度程序接着处理下一个进程。当大于时间片时，定时器会中断，进而操作系统中断，然后进行上下文切换，将进程加入到队列尾部。     
上下文切换也是有时间开销的，如果时间片设置过小，会造成大量的上下文切换，严重浪费 CPU 资源。如果设置过大，RR 算法就会退化成为 FCFS 算法。        
大多数现代操作系统都将时间片设置为 10 ~ 100ms。     

## 5. 多级队列调度
// TODO
