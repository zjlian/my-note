如今的编程语言大多数都支持垃圾回收机制。垃圾回收的实现大致可以分成两类，**基于引用计数 (reference counting garbage collector)** 和 **基于跟踪处理 (tracing garbage collector)** 的。

## 基于引用计数的垃圾回收器
这种很简单，引用计数就是记录对象被引用（引用或指针）的次数。当对象的引用为 0 时，就可以回收了。   
优点: 
* 实现简单。
* 在合适的时机立即对单个对象进行回收，不会使程序暂停。

缺点
* 难以处理"循环引用"。
* 引用计数带来额外的运行时开销。

## 基于跟踪处理的垃圾回收
如今的编程语言的垃圾回收机制基本上用的都是基于跟踪处理的垃圾回收。   
其基本方法就是生成一个对象的引用关系图，然后进行垃圾回收。    
算法基本可以分为以下几种:   
### (1) 标记-清除 (Mark-Sweep)
两个步骤。标记，将程序中正在使用的对象看作“根对象”，从这些根对象开始遍历查找他们所引用的堆空间（对象），并在这些堆空间上做标记。   
当遍历结束后，所有被做了标记的对象被称为可达对象 (Reachable Object) 或活动象 (Live Object)，而没有被标记的对象就是垃圾了。第二步遍历所有对象，回收没被标记的垃圾。   
优点：
* 实现简单。
* 不会移动对象在堆内存中的位置。

缺点：
* 会造成内存碎片化，这是个很严重的问题（严重影响内存的使用率和大内存分配效率）。
* 会使程序暂停，进行回收工作。

### (2) 标记-整理 (Mark-Compact)
这个方法的第一步与”标记-清除“法一致，标记完后的第二步，不再需要遍历所有对象，而是将可达对象“左移”，把他们都拷贝到堆内存空间开始的位置。   
优点：
* 解决了内存碎片问题。
  
缺点：
* 因为移动了对象在堆内存中的位置，需要更新程序中对象引用的地址。
* 会使程序暂停，进行回收工作。

### (3) 标记-拷贝 (Mark-Copy)
此法将堆内存空间对半划分为两个部分：From 和 To。   
所用的内存分配工作都在 From 区域进行，当 From 满的时候开始垃圾回收。
第一步与前面的方法一样，标记出所有的可达对象，然后吧他们都拷贝到 To 空间。完成后 From 空间剩下的就都是垃圾了。   
最后只需要将 From 和 To 调换下角色就完事了，新的内存分配依旧在 From 空间进行。
优点：
* 与“标记-整理”法相同

缺点：
* 与“标记-整理”法相同
* 内存使用率始终只有一半（有优化空间，优化后可使内存使用率提高到90%）。
