# 文章列表和大纲

## 杂项
### RAII 机制的拓展用法：实现 defer
   - defer 的作用和效果
   - 为什么需要 defer
   - 什么是 RAII
   - 实现一个最简单的 defer
   - 使用运算符重载和宏实现语法糖
   - 使用模板消除运行时开销

### 固定频率执行循环体
   - 定频循环与普通 sleep 的效果差别
   - 为什么需要定频循环
   - 如何实现

### 读写锁和互斥锁的选择
   - 锁的作用
   - 锁的原理
   - 读写锁的实现差异
   - 什么时候需要读写锁

### 快速泊松碟采样算法
   - 应用场景
   - 算法特点
   - 实现方式

## 优化类
### 探索模块使用的性能优化方法：内存和并行计算
   - 分析性能瓶颈的方法
   - 减少动态内存分配的方法
   - 局部性原理，有效利用cpu高速缓存
   - 并行化重复性的计算

## 轮子类
### 如何为并行计算设计一个线程池和相关工具
   - 为什么需要线程池
   - 并行计算所需的线程池是什么样的
   - 线程池的接口和用法
   - 实现一个最简单的线程池
   - 实现一个简单高效的线程安全队列
   - 线程局部任务队列
   - 任务窃取
   - 阻塞等待线程池内的任务结果
   - 封装 Async() 和 Parallel()

### 如何追踪程序的调用栈，并在程序崩溃时打印
   - 什么是调用栈
   - Linux 系统提供的 backtrace() 函数的原理
   - 倒推法获取调用栈的缺陷
   - 利用编译器拓展功能追踪调用栈
   - 如何通过函数指针获取函数名
   - 程序如何知道自己的崩溃原因和造成崩溃的代码
   - Linux 信号处理的坑

### 如何统计各条线程的内存分配释放情况
   - c++ 的内存分配流程
   - 重载 operator new 和 operator delete
   - 使用 Hook 技术，重载进程内的所有 malloc() 和 free() 
   - 如何追踪记录跨线程释放的内存
